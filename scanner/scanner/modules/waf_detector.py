"""WAF (Web Application Firewall) detection module."""

import re
import time
from typing import Any

import httpx

from scanner.config import config
from scanner.logger import logger
from scanner.models import (
    Asset,
    BaseModule,
    Finding,
    ModuleResult,
    Severity,
    VulnCategory,
)


# WAF signature database - maps WAF name to detection rules
WAF_SIGNATURES: dict[str, dict[str, Any]] = {
    "Cloudflare": {
        "headers": {"server": "cloudflare", "cf-ray": ""},
        "cookies": ["__cfduid", "cf_clearance", "__cf_bm"],
        "body_patterns": [r"cloudflare", r"cf-error-details"],
    },
    "AWS WAF / CloudFront": {
        "headers": {"x-amz-cf-id": "", "x-amz-cf-pop": "", "server": "cloudfront"},
        "cookies": ["awsalb", "awsalbcors", "AWSALB"],
        "body_patterns": [r"<Code>AccessDenied</Code>"],
    },
    "Akamai": {
        "headers": {"x-akamai-transformed": "", "server": "akamaighost"},
        "cookies": ["akamai_generated"],
        "body_patterns": [r"akamaighost", r"AkamaiGHost"],
    },
    "Imperva / Incapsula": {
        "headers": {"x-cdn": "incapsula", "x-iinfo": ""},
        "cookies": ["visid_incap_", "incap_ses_", "_incapsula_"],
        "body_patterns": [r"incapsula incident id", r"_Incapsula_Resource"],
    },
    "Sucuri": {
        "headers": {"x-sucuri-id": "", "server": "sucuri"},
        "cookies": ["sucuri_cloudproxy"],
        "body_patterns": [r"sucuri", r"cloudproxy"],
    },
    "ModSecurity": {
        "headers": {"server": "mod_security"},
        "cookies": [],
        "body_patterns": [
            r"mod_security",
            r"NOYB",
            r"This error was generated by Mod_Security",
        ],
    },
    "F5 BIG-IP ASM": {
        "headers": {"x-wa-info": "", "server": "bigip"},
        "cookies": ["TS", "BIGipServer", "f5_cspm"],
        "body_patterns": [r"BIG-IP", r"F5 Networks"],
    },
    "Barracuda": {
        "headers": {"server": "barracuda"},
        "cookies": ["barra_counter_session"],
        "body_patterns": [r"barracuda", r"Barracuda Web Application Firewall"],
    },
    "FortiWeb": {
        "headers": {"server": "fortiweb"},
        "cookies": ["FORTIWAFSID"],
        "body_patterns": [r"fortigate", r"fortiweb"],
    },
    "DDoS-Guard": {
        "headers": {"server": "ddos-guard"},
        "cookies": ["__ddg1", "__ddg2"],
        "body_patterns": [r"ddos-guard"],
    },
    "Wordfence": {
        "headers": {},
        "cookies": ["wfvt_", "wordfence_verifiedHuman"],
        "body_patterns": [r"wordfence", r"wfFunc"],
    },
    "Comodo WAF": {
        "headers": {"server": "protected by comodo"},
        "cookies": [],
        "body_patterns": [r"comodo waf"],
    },
}

# Payloads that typically trigger WAF blocks
WAF_TRIGGER_PAYLOADS = [
    "<script>alert(1)</script>",
    "' OR 1=1 --",
    "../../etc/passwd",
    "{{7*7}}",
    "${7*7}",
    "| ls -la",
]


class WafDetector(BaseModule):
    """Detects the presence and type of Web Application Firewalls."""

    @property
    def name(self) -> str:
        return "waf_detector"

    @property
    def description(self) -> str:
        return "Detects Web Application Firewalls (WAF) protecting the target"

    async def run(self, target: str, options: dict[str, Any] | None = None) -> ModuleResult:
        opts = options or {}
        start = time.time()
        assets: list[Asset] = []
        findings: list[Finding] = []
        errors: list[str] = []
        raw_output: dict[str, Any] = {}

        base_url = target if target.startswith("http") else f"https://{target}"
        log = logger.bind(target=target)
        log.info("Starting WAF detection")

        detected_wafs: list[str] = []

        async with httpx.AsyncClient(
            timeout=config.http_timeout,
            follow_redirects=True,
            verify=False,
            headers={"User-Agent": config.http_user_agent},
        ) as client:
            # 1. Passive detection from normal response headers/cookies
            try:
                resp = await client.get(base_url)
                detected_wafs.extend(
                    self._check_response_signatures(resp)
                )
                raw_output["normal_response_status"] = resp.status_code
            except Exception as e:
                errors.append(f"Normal request failed: {e}")

            # 2. Active detection - send malicious payloads and check response
            for payload in WAF_TRIGGER_PAYLOADS:
                try:
                    trigger_url = f"{base_url}/?test={payload}"
                    resp = await client.get(trigger_url)

                    # WAF typically returns 403, 406, 429, 501, 503
                    if resp.status_code in (403, 406, 429, 501, 503):
                        raw_output["waf_block_detected"] = True
                        raw_output["blocked_status"] = resp.status_code

                        # Check blocked response for WAF signatures
                        active_wafs = self._check_response_signatures(resp)
                        for waf in active_wafs:
                            if waf not in detected_wafs:
                                detected_wafs.append(waf)

                        # Check body for generic block messages
                        body_lower = resp.text.lower()
                        block_indicators = [
                            "blocked", "forbidden", "access denied", "firewall",
                            "security policy", "request rejected", "not acceptable",
                            "waf", "web application firewall",
                        ]
                        if any(ind in body_lower for ind in block_indicators):
                            raw_output["block_page_detected"] = True
                        break  # One block detection is enough

                except Exception:
                    pass

        # Record detected WAFs
        if detected_wafs:
            unique_wafs = list(set(detected_wafs))
            raw_output["detected_wafs"] = unique_wafs

            for waf_name in unique_wafs:
                assets.append(
                    Asset(
                        type="TECHNOLOGY",
                        value=f"WAF: {waf_name}",
                        metadata={"type": "waf", "name": waf_name},
                    )
                )

            findings.append(
                Finding(
                    title=f"WAF Detected: {', '.join(unique_wafs)}",
                    severity=Severity.INFO,
                    category=VulnCategory.WAF_DETECTED,
                    description=(
                        f"Web Application Firewall detected: {', '.join(unique_wafs)}. "
                        "WAF presence means some attack payloads may be filtered, "
                        "but it does not guarantee the application is secure."
                    ),
                    solution=(
                        "WAF is a defense-in-depth measure. Ensure the underlying "
                        "application is also secure regardless of WAF protection."
                    ),
                    affected_component=base_url,
                    evidence=f"Detected WAFs: {', '.join(unique_wafs)}",
                )
            )
        else:
            raw_output["detected_wafs"] = []
            findings.append(
                Finding(
                    title="No WAF Detected",
                    severity=Severity.LOW,
                    category=VulnCategory.WAF_DETECTED,
                    description=(
                        "No Web Application Firewall was detected protecting the target. "
                        "The application may be directly exposed to attack traffic."
                    ),
                    solution=(
                        "Consider deploying a WAF (e.g., Cloudflare, AWS WAF, ModSecurity) "
                        "as an additional defense layer."
                    ),
                    affected_component=base_url,
                )
            )

        log.info("WAF detection completed", wafs=len(detected_wafs))

        return ModuleResult(
            module_name=self.name,
            assets=assets,
            findings=findings,
            raw_output=raw_output,
            errors=errors,
            duration_seconds=time.time() - start,
        )

    @staticmethod
    def _check_response_signatures(resp: httpx.Response) -> list[str]:
        """Check HTTP response headers, cookies, and body for WAF signatures."""
        detected: list[str] = []
        headers_lower = {k.lower(): v.lower() for k, v in resp.headers.items()}
        cookie_header = resp.headers.get("set-cookie", "").lower()
        body = resp.text[:5000]  # Only check first 5KB

        for waf_name, sigs in WAF_SIGNATURES.items():
            # Check headers
            for header_key, header_val in sigs.get("headers", {}).items():
                if header_key in headers_lower:
                    if not header_val or header_val in headers_lower[header_key]:
                        detected.append(waf_name)
                        break

            if waf_name in detected:
                continue

            # Check cookies
            for cookie_name in sigs.get("cookies", []):
                if cookie_name.lower() in cookie_header:
                    detected.append(waf_name)
                    break

            if waf_name in detected:
                continue

            # Check body patterns
            for pattern in sigs.get("body_patterns", []):
                if re.search(pattern, body, re.IGNORECASE):
                    detected.append(waf_name)
                    break

        return detected
